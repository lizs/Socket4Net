<?xml version="1.0"?>
<doc>
    <assembly>
        <name>socket4net</name>
    </assembly>
    <members>
        <member name="T:socket4net.BatchedScheduler">
            <summary>
                Batch定时器调度器
            </summary>
        </member>
        <member name="T:socket4net.Obj">
            <summary>
                对象基类
            </summary>
        </member>
        <member name="T:socket4net.IObj">
            <summary>
                Interface Obj
            </summary>
        </member>
        <member name="M:socket4net.IObj.CompareTo(socket4net.IObj)">
            <summary>
                comparer
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.IObj.Init(socket4net.ObjArg)">
            <summary>
                Initialize
            </summary>
            <param name="arg"></param>
        </member>
        <member name="M:socket4net.IObj.Born">
            <summary>
                Born
                Obj only born once during it's life circle
            </summary>
        </member>
        <member name="M:socket4net.IObj.Start">
            <summary>
                Run
            </summary>
        </member>
        <member name="M:socket4net.IObj.Destroy">
            <summary>
                Destroy
            </summary>
        </member>
        <member name="M:socket4net.IObj.GetAncestor``1">
            <summary>
                Get obj's ancestor
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.IObj.GetUserData``1">
            <summary>
                Get user data
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.IObj.SetUserData(System.Object)">
            <summary>
                Set user data
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:socket4net.IObj.WaitFor(System.UInt32)">
            <summary>
                Create an IEnumerator used in Coroutine scheduler
                to waiting for 'n' ms
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.IObj.StopCoroutine(socket4net.Coroutine)">
            <summary>
                Stop 'coroutine'
            </summary>
            <param name="coroutine"></param>
        </member>
        <member name="M:socket4net.IObj.StartCoroutine(System.Func{System.Collections.IEnumerator})">
            <summary>
                Start 'fun' as an coroutine
            </summary>
            <param name="fun"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.IObj.StartCoroutine(System.Func{System.Object[],System.Collections.IEnumerator},System.Object[])">
            <summary>
                Start 'fun' as an coroutine
            </summary>
            <param name="fun"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.IObj.ClearTimers">
            <summary>
                clear timers attached on this obj
            </summary>
        </member>
        <member name="M:socket4net.IObj.InvokeRepeating(System.Action,System.UInt32,System.UInt32)">
            <summary>
                Excute 'action' after 'delay' ms for every 'period' ms
            </summary>
        </member>
        <member name="M:socket4net.IObj.Invoke(System.Action,System.UInt32)">
            <summary>
                Excute 'action' after 'delay' ms
            </summary>
            <param name="action"></param>
            <param name="delay"></param>
        </member>
        <member name="M:socket4net.IObj.Invoke(System.Action,System.DateTime)">
            <summary>
                Excute 'action' when 'when'
            </summary>
            <param name="action"></param>
            <param name="when"></param>
        </member>
        <member name="M:socket4net.IObj.Invoke(System.Action,System.Int32,System.Int32,System.Int32)">
            <summary>
                Excute 'action' every 'hour:min:s'
            </summary>
            <param name="action"></param>
            <param name="hour"></param>
            <param name="min"></param>
            <param name="s"></param>
        </member>
        <member name="M:socket4net.IObj.Invoke(System.Action,System.TimeSpan)">
            <summary>
                Excute 'action' everyday's 'time' clock
            </summary>
            <param name="action"></param>
            <param name="time"></param>
        </member>
        <member name="M:socket4net.IObj.CancelInvoke(System.Action)">
            <summary>
                Cancel 'action'
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:socket4net.IObj.InvokeAsync(System.Action,System.TimeSpan[])">
            <summary>
                Excute 'action' everyday's 'times' clock
            </summary>
        </member>
        <member name="M:socket4net.IObj.InvokeAsync(System.Action,System.DateTime[])">
            <summary>
                Excute 'action' when 'whens'
            </summary>
        </member>
        <member name="M:socket4net.IObj.InvokeAsync(System.Action,System.TimeSpan)">
            <summary>
                Excute 'action' everyday's 'time' clock
            </summary>
            <param name="action"></param>
            <param name="time"></param>
        </member>
        <member name="M:socket4net.IObj.InvokeAsync(System.Action,System.DateTime)">
            <summary>
                Excute 'action' when 'when'
            </summary>
            <param name="action"></param>
            <param name="when"></param>
        </member>
        <member name="M:socket4net.IObj.InvokeAsync(System.Action,System.UInt32)">
            <summary>
                Excute 'action' after 'delay' ms
            </summary>
            <param name="action"></param>
            <param name="delay"></param>
        </member>
        <member name="P:socket4net.IObj.InstanceId">
            <summary>
                Obj instance id
                Unique only before current process dead
            </summary>
        </member>
        <member name="P:socket4net.IObj.Owner">
            <summary>
                Owner
            </summary>
        </member>
        <member name="P:socket4net.IObj.Name">
            <summary>
                name
            </summary>
        </member>
        <member name="P:socket4net.IObj.Priority">
            <summary>
                Schedule priority
                Just like Unity's layer
            </summary>
        </member>
        <member name="P:socket4net.IObj.OwnerDescription">
            <summary>
                Owner description
            </summary>
        </member>
        <member name="P:socket4net.IObj.Initialized">
            <summary>
                If initialized
            </summary>
        </member>
        <member name="P:socket4net.IObj.Started">
            <summary>
                If started
            </summary>
        </member>
        <member name="P:socket4net.IObj.Destroyed">
            <summary>
                If destroyed
            </summary>
        </member>
        <member name="P:socket4net.IObj.Fresh">
            <summary>
                If IObj's 'Born' invoked 
            </summary>
        </member>
        <member name="F:socket4net.Obj.MillisecondsPerDay">
            <summary>
                
            </summary>
        </member>
        <member name="M:socket4net.Obj.WaitFor(System.UInt32)">
            <summary>
                产生一个在逻辑线程等待n毫秒的枚举器
                用在协程中
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.Obj.OnInit(socket4net.ObjArg)">
            <summary>
               internal called when an Obj is initialized
            </summary>
            <param name="arg"></param>
        </member>
        <member name="M:socket4net.Obj.OnDestroy">
            <summary>
               internal called when an Obj is to be destroyed
            </summary>
        </member>
        <member name="M:socket4net.Obj.ClearTimers">
            <summary>
                清理调度器
            </summary>
        </member>
        <member name="M:socket4net.Obj.InvokeRepeating(System.Action,System.UInt32,System.UInt32)">
            <summary>
                延时delay，以period为周期重复执行action
            </summary>
        </member>
        <member name="M:socket4net.Obj.Invoke(System.Action,System.UInt32)">
            <summary>
                延时delay，执行action
            </summary>
            <param name="action"></param>
            <param name="delay"></param>
        </member>
        <member name="M:socket4net.Obj.Invoke(System.Action,System.DateTime)">
            <summary>
                在when时间点执行action
            </summary>
            <param name="action"></param>
            <param name="when"></param>
        </member>
        <member name="M:socket4net.Obj.Invoke(System.Action,System.Int32,System.Int32,System.Int32)">
            <summary>
                每天 hour:min:s 执行action
                如：每天20:15执行action，此时 hour == 20 min == 15 s == 0
            </summary>
            <param name="action"></param>
            <param name="hour"></param>
            <param name="min"></param>
            <param name="s"></param>
        </member>
        <member name="M:socket4net.Obj.Invoke(System.Action,System.TimeSpan)">
            <summary>
                每天 time 执行action
                注：time并非间隔
            </summary>
            <param name="action"></param>
            <param name="time"></param>
        </member>
        <member name="M:socket4net.Obj.CancelInvoke(System.Action)">
            <summary>
                取消action的调度
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:socket4net.Obj.InvokeAsync(System.Action,System.TimeSpan[])">
            <summary>
                每日的times时间点执行action
            </summary>
            
        </member>
        <member name="M:socket4net.Obj.InvokeAsync(System.Action,System.DateTime[])">
            <summary>
                在whens指定的时间点执行action
            </summary>
        </member>
        <member name="M:socket4net.Obj.#ctor">
            <summary>
                Constructor
                InstanceId is assigned here
            </summary>
        </member>
        <member name="M:socket4net.Obj.New``1(socket4net.ObjArg,System.Boolean)">
            <summary>
                Create an obj of type 'T' with arg
                If 'start' == true, Obj will be started after initialized
            </summary>
            <returns></returns>
        </member>
        <member name="M:socket4net.Obj.New(System.Type,socket4net.ObjArg,System.Boolean)">
            <summary>
                Create an obj of 'type' with arg
                If 'start' == true, Obj will be started after initialized
            </summary>
            <returns></returns>
        </member>
        <member name="M:socket4net.Obj.New``1(System.Type,socket4net.ObjArg,System.Boolean)">
            <summary>
                Create an obj of 'type' with arg and return 'obj as T'
                If 'start' == true, Obj will be started after initialized
            </summary>
            <returns></returns>
        </member>
        <member name="M:socket4net.Obj.OnStart">
            <summary>
                Invoked when obj started
            </summary>
        </member>
        <member name="M:socket4net.Obj.Destroy">
            <summary>
                Invoked when obj destroyed
            </summary>
        </member>
        <member name="M:socket4net.Obj.OnBorn">
            <summary>
                Invoked when obj born
            </summary>
        </member>
        <member name="P:socket4net.Obj.OwnerDescription">
            <summary>
                Owner description
            </summary>
        </member>
        <member name="M:socket4net.BatchedScheduler.#ctor(socket4net.IFlushable)">
            <summary>
            
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:socket4net.BatchedScheduler.InternalInvokeRepeating(System.Action,System.UInt32,System.UInt32)">
            <summary>
                Internal invoker for Obj
            </summary>
            <param name="action"></param>
            <param name="delay"></param>
            <param name="period"></param>
        </member>
        <member name="M:socket4net.BatchedScheduler.InternalInvoke(System.Action,System.UInt32)">
            <summary>
                Internal invoker for Obj
            </summary>
            <param name="action"></param>
            <param name="delay"></param>
            <param name="period"></param>
        </member>
        <member name="T:socket4net.DefaultDataProtocol">
            <summary>
            socket4net's default data protocol
            </summary>
        </member>
        <member name="T:socket4net.IDataProtocol">
            <summary>
                数据协议
                网络数据按照该协议解析
            </summary>
        </member>
        <member name="T:socket4net.IDispatchableSession">
            <summary>
                diapatchable session
                dispath request/push by DispatchProto
            </summary>
        </member>
        <member name="T:socket4net.ISession">
            <summary>
                Session
                Indicate a link between client and server
            </summary>
        </member>
        <member name="M:socket4net.ISession.Close(socket4net.SessionCloseReason)">
            <summary>
                Close this session
            </summary>
            <param name="reason"></param>
        </member>
        <member name="M:socket4net.ISession.InternalSend(socket4net.NetPackage)">
            <summary>
                Send message to peer
            </summary>
            <param name="pack"></param>
        </member>
        <member name="P:socket4net.ISession.UnderlineSocket">
            <summary>
                Socket attached to this session
            </summary>
        </member>
        <member name="P:socket4net.ISession.ReceiveBufSize">
            <summary>
            
            </summary>
        </member>
        <member name="P:socket4net.ISession.PackageMaxSize">
            <summary>
            
            </summary>
        </member>
        <member name="M:socket4net.IDispatchableSession.MultiCast``1(``0,System.Collections.Generic.IEnumerable{socket4net.ISession})">
            <summary>
                Push message to clients specified by 'sessions'
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proto"></param>
            <param name="sessions"></param>
        </member>
        <member name="M:socket4net.IDispatchableSession.Broadcast``1(``0)">
            <summary>
                Push message to all the clients
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proto"></param>
        </member>
        <member name="M:socket4net.IDispatchableSession.RequestAsync``1(``0,System.Action{System.Boolean,System.Byte[]})">
            <summary>
            </summary>
            <param name="proto"></param>
            <param name="cb"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:socket4net.IDispatchableSession.Push``1(``0)">
            <summary>
            </summary>
            <param name="proto"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:socket4net.SessionCloseReason">
            <summary>
                Session closed reason
            </summary>
        </member>
        <member name="F:socket4net.SessionCloseReason.ClosedByMyself">
            <summary>
                By me
            </summary>
        </member>
        <member name="F:socket4net.SessionCloseReason.ClosedByRemotePeer">
            <summary>
                By peer
            </summary>
        </member>
        <member name="F:socket4net.SessionCloseReason.ReadError">
            <summary>
                Read error
            </summary>
        </member>
        <member name="F:socket4net.SessionCloseReason.WriteError">
            <summary>
                Write error
            </summary>
        </member>
        <member name="F:socket4net.SessionCloseReason.PackError">
            <summary>
                Pack error
                That's mean data can't packaged by DataParser or data is much too huge
            </summary>
        </member>
        <member name="F:socket4net.SessionCloseReason.Replaced">
            <summary>
                Replaced
            </summary>
        </member>
        <member name="T:socket4net.Assert">
            <summary>
            
            </summary>
        </member>
        <member name="M:socket4net.Convertor.To``1(System.String)">
            <summary>
                generic parse an object from string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.Convertor.To(System.String,System.Type)">
            <summary>
                non-generic convertor
            </summary>
            <param name="input"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:socket4net.DictionaryExt">
            <summary>
                extension for dictionary
            </summary>
        </member>
        <member name="T:socket4net.ListExt">
            <summary>
            extension for list
            </summary>
        </member>
        <member name="T:socket4net.Rand">
            <summary>
                random num generator
            </summary>
        </member>
        <member name="M:socket4net.Rand.Next(System.Int32[])">
            <summary>
                在总长为Sum(input)的线段中随机一个点
                返回随机点所在的区间索引
            
                例如：
                    Next(1, 3, 6)
                    长度为10的线段，以1/3/6为长度连续划分为3段，亦即[0,1),[1,4),[4,10)
                若Next(10)=5，此时5落在第3段，所以返回2
                若Next(10)=1, 则返回0
                若Next(10)=2, 则返回1
                等...
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:socket4net.Rand.Next(System.Int32,System.Int32,System.Int32)">
            <summary>
                [min, max)区间内随机cnt个不重数
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <param name="cnt"></param>
            <returns></returns>
        </member>
        <member name="T:socket4net.FileExt">
            <summary>
            
            </summary>
        </member>
        <member name="T:socket4net.Add`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:socket4net.Multiply`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:socket4net.Treble`3">
            <summary>
            用于解析诸如 1 2 4 + 3 3 5 + 7 6 9 这种类型的string
            </summary>
        </member>
        <member name="M:socket4net.TaskHelper.ExcuteAsync``1(System.Func{``0})">
            <summary>
                异步执行
            </summary>
        </member>
        <member name="M:socket4net.TaskHelper.ExcuteAsync``2(``0,System.Func{``0,``1})">
            <summary>
                异步执行
            </summary>
        </member>
        <member name="T:socket4net.Coroutine">
            <summary>
                协程
            </summary>
        </member>
        <member name="M:socket4net.Coroutine.Update">
            <summary>
                每帧执行一次
            </summary>
            <returns>false表示协程未完毕，反之协程已完毕</returns>
        </member>
        <member name="M:socket4net.Coroutine.Process(System.Collections.IEnumerator)">
            <summary>
                处理枚举器
            </summary>
            <param name="enumerator"></param>
            <returns>
                False表示当前无任务
                True表示还有任务需处理
            </returns>
        </member>
        <member name="T:socket4net.DefaultLogger">
            <summary>
                socket4net's default logger
            </summary>
        </member>
        <member name="T:socket4net.ILog">
            <summary>
                Logger interface
            </summary>
        </member>
        <member name="M:socket4net.ILog.Debug(System.Object)">
            <summary>
                Log as debug level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Debug(System.String,System.Object[])">
            <summary>
                Log as debug level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Error(System.Object)">
            <summary>
                Log as error level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Error(System.String,System.Object[])">
            <summary>
                Log as error level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Fatal(System.Object)">
            <summary>
                Log as fatal level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Fatal(System.String,System.Object[])">
            <summary>
                Log as fatal level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Info(System.Object)">
            <summary>
                Log as information level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Info(System.String,System.Object[])">
            <summary>
                Log as information level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Warn(System.Object)">
            <summary>
                Log as warnning level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Warn(System.String,System.Object[])">
            <summary>
                Log as warnning level
            </summary>
        </member>
        <member name="M:socket4net.ILog.Exception(System.String,System.Exception)">
            <summary>
                Log exception
            </summary>
            <param name="msg"></param>
            <param name="e"></param>
        </member>
        <member name="M:socket4net.ILog.Shutdown">
            <summary>
                Destroy logger
            </summary>
        </member>
        <member name="T:socket4net.EmptyLogger">
            <summary>
                Empty logger
            </summary>
        </member>
        <member name="T:socket4net.Mgr`1">
            <summary>
                对象管理器
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:socket4net.ObjArg">
            <summary>
                Arguments used to initialize an Obj
            </summary>
        </member>
        <member name="M:socket4net.ObjArg.#ctor(socket4net.IObj)">
            <summary>
                Constructor
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:socket4net.ObjArg.As``1">
            <summary>
                Cast this arg to T
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="P:socket4net.ObjArg.Owner">
            <summary>
                Owner of to be initialized Obj
            </summary>
        </member>
        <member name="P:socket4net.ObjArg.Empty">
            <summary>
                Empty obj argument
            </summary>
        </member>
        <member name="T:socket4net.EmptyArg">
            <summary>
                Empty obj argument
            </summary>
        </member>
        <member name="M:socket4net.EmptyArg.#ctor">
            <summary>
                Constructor
            </summary>
        </member>
        <member name="T:socket4net.UniqueObj`1">
            <summary>
                拥有唯一Id（容器内唯一，不一定是Guid）
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="P:socket4net.UniqueObj`1.Id">
            <summary>
                唯一Id
            </summary>
        </member>
        <member name="P:socket4net.UniqueObj`1.Name">
            <summary>
                名字
            </summary>
        </member>
        <member name="T:socket4net.AutoWatch">
            <summary>
                Automatic time watcher
            </summary>
        </member>
        <member name="M:socket4net.AutoWatch.#ctor(System.String,System.Int64,System.Action{System.String,System.Int64})">
            <summary>
                constructor
            </summary>
            <param name="name"></param>
            <param name="threhold"></param>
            <param name="handler"></param>
        </member>
        <member name="P:socket4net.AutoWatch.Name">
            <summary>
                Watcher name
            </summary>
        </member>
        <member name="P:socket4net.AutoWatch.Threhold">
            <summary>
                Wather threhold 
                Warnning will be raised when elapsed ms > threhold
            </summary>
        </member>
        <member name="P:socket4net.AutoWatch.Handler">
            <summary>
                Callback when this watch disposed
            </summary>
        </member>
        <member name="P:socket4net.AutoWatch.ElapsedMilliseconds">
            <summary>
                Get elapsed ms since this watch constructed
            </summary>
        </member>
        <member name="T:socket4net.LinqExt">
            <summary>
                extension for LINQ
            </summary>
        </member>
        <member name="M:socket4net.LinqExt.IsNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            
            </summary>
            <param name="enumerable"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:socket4net.LinqExt.Split``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
                分组,对分
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <param name="parts"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.LinqExt.NextRand``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
                get next random item from input
            </summary>
            <typeparam name="T"></typeparam>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:socket4net.Value">
            <summary>
                bytes反序列化成Value
            </summary>
        </member>
        <member name="T:socket4net.ValueProto`1">
            <summary>
                包装一个值以用在序列化
                注意：Value并不是IProtobufInstance
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:socket4net.ValueProto`1.#ctor">
            <summary>
                for pb
            </summary>
        </member>
        <member name="T:socket4net.PiSerializer">
            <summary>
                基于protobuf的序列化器
                注：尽可能使用泛型接口
            </summary>
        </member>
        <member name="M:socket4net.PiSerializer.Serialize``1(``0)">
            <summary>
                序列化一个protobuf实例
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proto"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.PiSerializer.Deserialize``1(System.Byte[])">
            <summary>
                反序列化为一个pb实例
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.PiSerializer.SerializeValue``1(``0)">
            <summary>
                序列化一个值
                比如：int, float, long ...
            </summary>
            <typeparam name="T">值类型</typeparam>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:socket4net.PiSerializer.DeserializeValue``1(System.Byte[])" -->
        <member name="M:socket4net.PiSerializer.Deserialize(System.Type,System.Byte[])">
            <summary>
                非泛型方式的反序列化
                仅用于pb实例
            </summary>
        </member>
        <member name="P:socket4net.Launcher.LogicService">
            <summary>
                逻辑服务
            </summary>
        </member>
        <member name="P:socket4net.Launcher.NetService">
            <summary>
                网络服务
            </summary>
        </member>
        <member name="T:socket4net.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage
            </summary>
            <example><code>
            [CanBeNull] public object Test() { return null; }
            public void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:socket4net.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>
            </summary>
            <example><code>
            [NotNull] public object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:socket4net.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            public void ShowError(string message, params object[] args) { /* do something */ }
            public void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:socket4net.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:socket4net.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>
            </summary>
            <example><code>
            public void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:socket4net.Annotations.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> interface
             and this method is used to notify that some property value changed
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               private string _name;
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:socket4net.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the methos doesn't return normally.<br/>
            <c>canbenull</c> annotation is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null, and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:socket4net.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            public class Foo {
              private string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:socket4net.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            class UsesNoEquality {
              public void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:socket4net.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked
            with the target attribute to implement or inherit specific type or types.
            </summary>
            <example><code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            public class ComponentAttribute : Attribute { }
            [Component] // ComponentAttribute requires implementing IComponent interface
            public class MyComponent : IComponent { }
            </code></example>
        </member>
        <member name="T:socket4net.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly
            (e.g. via reflection, in external library), so this symbol
            will not be marked as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="T:socket4net.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper
            to not mark symbols marked with such attributes as unused
            (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:socket4net.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used</summary>
        </member>
        <member name="F:socket4net.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member</summary>
        </member>
        <member name="F:socket4net.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:socket4net.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type</summary>
        </member>
        <member name="T:socket4net.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly
            when marked with <see cref="T:socket4net.Annotations.MeansImplicitUseAttribute"/>
            or <see cref="T:socket4net.Annotations.UsedImplicitlyAttribute"/>
            </summary>
        </member>
        <member name="F:socket4net.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used</summary>
        </member>
        <member name="F:socket4net.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used</summary>
        </member>
        <member name="T:socket4net.Annotations.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used
            </summary>
        </member>
        <member name="T:socket4net.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled
            when the invoked method is on stack. If the parameter is a delegate,
            indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated
            while the method is executed
            </summary>
        </member>
        <member name="T:socket4net.Annotations.PureAttribute">
            <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c>
            </summary>
            <example><code>
            [Pure] private int Multiply(int x, int y) { return x * y; }
            public void Foo() {
              const int a = 2, b = 2;
              Multiply(a, b); // Waring: Return value of pure method is not used
            }
            </code></example>
        </member>
        <member name="T:socket4net.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder
            within a web project. Path can be relative or absolute,
            starting from web root (~)
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that
            the parameter is an MVC controller. If applied to a method,
            the MVC controller name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC Master.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(String, String)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC model type.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(String, Object)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that
            the parameter is an MVC partial view. If applied to a method,
            the MVC partial view name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcSupressViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling all inspections
            for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>
            </summary>
        </member>
        <member name="T:socket4net.Annotations.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name
            </summary>
            <example><code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:socket4net.Annotations.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that a parameter or a method is a Razor section.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>
            </summary>
        </member>
        <member name="T:socket4net.CoroutineScheduler">
            <summary>
                协程调度器
            </summary>
        </member>
        <member name="T:socket4net.TimerWrapper">
            <summary>
            基于socket4net逻辑服务的定时器
            </summary>
        </member>
        <member name="M:socket4net.UniqueMgr`3.Create``1(socket4net.UniqueObjArg{`1},System.Boolean)">
            <summary>
                创建
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arg"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.UniqueMgr`3.Create(System.Type,socket4net.UniqueObjArg{`1},System.Boolean)">
            <summary>
                非泛型创建
            </summary>
            <param name="type"></param>
            <param name="arg"></param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.UniqueMgr`3.Create``1(System.Type,socket4net.UniqueObjArg{`1},System.Boolean)">
            <summary>
                非泛型创建，并cast成T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.UniqueMgr`3.CreateDefault``1(socket4net.UniqueObjArg{`1},System.Boolean)">
            <summary>
                创建默认
            </summary>
            <typeparam name="T"></typeparam>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.UniqueMgr`3.CreateDefault(System.Type,socket4net.UniqueObjArg{`1},System.Boolean)">
            <summary>
                非泛型创建默认
            </summary>
            <param name="type"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.UniqueMgr`3.CreateDefault``1(System.Type,socket4net.UniqueObjArg{`1},System.Boolean)">
            <summary>
                非泛型创建默认，并cast成T
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="T:socket4net.UniqueMgr`2">
            <summary>
                对象管理器
                对象之间以id唯一区分
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:socket4net.GlobalVarPool">
            <summary>
                全局变量池
            </summary>
        </member>
        <member name="T:socket4net.DispatchalbeClient`1">
            <summary>
                Client with dispatchable session
            </summary>
            <typeparam name="TSession"></typeparam>
        </member>
        <member name="T:socket4net.Client`1">
            <summary>
            
            </summary>
            <typeparam name="TSession"></typeparam>
        </member>
        <member name="T:socket4net.IClient">
            <summary>
            
            </summary>
        </member>
        <member name="T:socket4net.IPeer">
            <summary>
                Peer abstract
            终端
            对服务器、客户端的抽象
            </summary>
        </member>
        <member name="M:socket4net.IPeer.PerformInLogic(System.Action)">
            <summary>
                Excute 'action' in logic service
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:socket4net.IPeer.PerformInLogic``1(System.Action{``0},``0)">
            <summary>
                Excute 'action' in logic service
            </summary>
            <param name="action"></param>
            <param name="param"></param>
        </member>
        <member name="M:socket4net.IPeer.PerformInNet(System.Action)">
            <summary>
                Excute 'action' in net service
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:socket4net.IPeer.PerformInNet``1(System.Action{``0},``0)">
            <summary>
                Excute 'action' in net service
            </summary>
            <param name="action"></param>
            <param name="param"></param>
        </member>
        <member name="P:socket4net.IPeer.Ip">
            <summary>
            
            </summary>
        </member>
        <member name="P:socket4net.IPeer.Port">
            <summary>
            
            </summary>
        </member>
        <member name="P:socket4net.IPeer.Address">
            <summary>
            
            </summary>
        </member>
        <member name="P:socket4net.IPeer.EndPoint">
            <summary>
            
            </summary>
        </member>
        <member name="P:socket4net.IPeer.SessionMgr">
            <summary>
                Get session manager
            </summary>
        </member>
        <member name="P:socket4net.IPeer.LogicService">
            <summary>
                Get logic service
            </summary>
        </member>
        <member name="P:socket4net.IPeer.NetService">
            <summary>
                Get net service
            </summary>
        </member>
        <member name="E:socket4net.IPeer.EventSessionClosed">
            <summary>
                Raised when a session closed
            </summary>
        </member>
        <member name="E:socket4net.IPeer.EventSessionEstablished">
            <summary>
                Raised when a session established
            </summary>
        </member>
        <member name="E:socket4net.IPeer.EventPeerClosing">
            <summary>
                Raised when Peer closing
            </summary>
        </member>
        <member name="E:socket4net.IPeer.EventErrorCatched">
            <summary>
                Raised when error catched
            </summary>
        </member>
        <member name="M:socket4net.IClient.Reconnect">
            <summary>
                Reconnect to server
            </summary>
        </member>
        <member name="M:socket4net.IClient.Connect">
            <summary>
                Connect to server
            </summary>
        </member>
        <member name="P:socket4net.IClient.Connected">
            <summary>
                If client is connected to server
            </summary>
        </member>
        <member name="F:socket4net.Client`1.ReconnectDelay">
            <summary>
                Default reconnect retry delay time
            </summary>
        </member>
        <member name="F:socket4net.Client`1.ReconnectMaxDelay">
            <summary>
                Default reconnect retry max delay time
            </summary>
        </member>
        <member name="E:socket4net.Client`1.EventSessionClosed">
            <summary>
                Raised when a session closed
            </summary>
        </member>
        <member name="E:socket4net.Client`1.EventSessionEstablished">
            <summary>
                Raised when a session established
            </summary>
        </member>
        <member name="E:socket4net.Client`1.EventPeerClosing">
            <summary>
                Raised when Peer closing
            </summary>
        </member>
        <member name="E:socket4net.Client`1.EventErrorCatched">
            <summary>
                Raised when error catched
            </summary>
        </member>
        <member name="P:socket4net.Client`1.AutoReconnectEnabled">
            <summary>
                是否在断开连接之后自动重连
            </summary>
        </member>
        <member name="P:socket4net.Client`1.ReconnectRetryDelay">
            <summary>
                重连重试延时
            </summary>
        </member>
        <member name="T:socket4net.NetProto">
            <summary>
            网络包协议
            二进制流格式：Length(2 Byte) + Body(Length Byte) + ... + Length(2 Byte) + Body(Length Byte)
            
            注意：本层仅负责打包一个个完整的Body
                      上层为Body提供反序列化方式（protobuf）
            </summary>
        </member>
        <member name="T:socket4net.Response">
            <summary>
                响应
            </summary>
        </member>
        <member name="T:socket4net.CircularBuffer">
            <summary>
            循环buffer
            </summary>
        </member>
        <member name="M:socket4net.CircularBuffer.#ctor(System.UInt16)">
            <summary>
            
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:socket4net.CircularBuffer.Read(System.Byte[]@,System.UInt16,System.UInt16)">
            <summary>
                Read data from head
            </summary>
            <param name="offset"></param>
            <param name="len"></param>
            <param name="buf"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.CircularBuffer.MoveByRead(System.UInt16)">
            <summary>
                Move head by 'len'
            </summary>
            <param name="len"></param>
            <returns></returns>
        </member>
        <member name="M:socket4net.CircularBuffer.MoveByWrite(System.UInt16)">
            <summary>
                Move tail by 'len'
            </summary>
            <param name="len"></param>
        </member>
        <member name="P:socket4net.CircularBuffer.Buffer">
            <summary>
                buffer
            </summary>
        </member>
        <member name="P:socket4net.CircularBuffer.Capacity">
            <summary>
                Capacity
            </summary>
        </member>
        <member name="P:socket4net.CircularBuffer.Head">
            <summary>
                Head
            </summary>
        </member>
        <member name="P:socket4net.CircularBuffer.Tail">
            <summary>
                Tail
            </summary>
        </member>
        <member name="P:socket4net.CircularBuffer.ReadableSize">
            <summary>
               Readable buffer size
            </summary>
        </member>
        <member name="P:socket4net.CircularBuffer.WritableSize">
            <summary>
               Writable buffer size
            </summary>
        </member>
        <member name="P:socket4net.CircularBuffer.Overload">
            <summary>
                Indicate if buffer is full
            </summary>
        </member>
        <member name="T:socket4net.Packer">
            <summary>
            拆包
            非线程安全，需要上层来确保始终在某个线程运行
            </summary>
        </member>
        <member name="T:socket4net.SessionArg">
            <summary>
             session arguments
            </summary>
        </member>
        <member name="M:socket4net.SessionArg.#ctor(socket4net.IPeer,System.Int64,System.Net.Sockets.Socket)">
            <summary>
            
            </summary>
            <param name="owner"></param>
            <param name="key"></param>
            <param name="underlineSock"></param>
        </member>
        <member name="P:socket4net.SessionArg.UnderlineSocket">
            <summary>
                under line socket associated to the target session
            </summary>
        </member>
        <member name="T:socket4net.Session">
            <summary>
                Session
            </summary>
        </member>
        <member name="F:socket4net.Session.DefaultPackageMaxSize">
            <summary>
                default maximum network package size
            </summary>
        </member>
        <member name="F:socket4net.Session.DefaultReceiveBufferSize">
            <summary>
                default receive buffer size
            </summary>
        </member>
        <member name="M:socket4net.Session.Dispatch(System.Byte[])">
            <summary>
            分包
            在LogicService线程分发
            </summary>
            <param name="data"></param>
        </member>
        <member name="P:socket4net.Session.HostPeer">
            <summary>
                Host peer this session belongs to
            </summary>
        </member>
        <member name="P:socket4net.Session.ReceiveBufSize">
            <summary>
            指定接收buffer长度
            </summary>
        </member>
        <member name="P:socket4net.Session.PackageMaxSize">
            <summary>
            限制包大小
            </summary>
        </member>
        <member name="P:socket4net.Session.Closed">
            <summary>
                Session already closed
            </summary>
        </member>
        <member name="T:socket4net.ERpc">
            <summary>
            Rpc类型
            C->S or S->C
            </summary>
        </member>
        <member name="F:socket4net.ERpc.Push">
            <summary>
            通知
            无需等待对端响应
            </summary>
        </member>
        <member name="F:socket4net.ERpc.Request">
            <summary>
            请求
            需要等待对端响应才能完成本次Rpc
            </summary>
        </member>
        <member name="F:socket4net.ERpc.Response">
            <summary>
            响应Request
            </summary>
        </member>
        <member name="T:socket4net.DispatchableSession">
            <summary>
                Dispatchable session
                Messages received from peer are dispatched here
            </summary>
        </member>
        <member name="M:socket4net.DispatchableSession.MultiCast``1(``0,System.Collections.Generic.IEnumerable{socket4net.ISession})">
            <summary>
            多播
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proto"></param>
            <param name="sessions"></param>
        </member>
        <member name="M:socket4net.DispatchableSession.Broadcast``1(``0)">
            <summary>
            广播
            </summary>
            <typeparam name="T"></typeparam>
            <param name="proto"></param>
        </member>
        <member name="M:socket4net.DispatchableSession.RequestAsync(System.UInt16,socket4net.NetPackage)">
            <summary>
                异步请求（按请求序列号回调结果）
            </summary>
            <param name="serial"></param>
            <param name="pack"></param>
            <returns></returns>
        </member>
        <member name="P:socket4net.DispatchableSession.DataParser">
            <summary>
                Get/Set custom data parser
            </summary>
        </member>
        <member name="T:socket4net.ServiceArg">
            <summary>
                Obj argument for service
            </summary>
        </member>
        <member name="P:socket4net.ServiceArg.Capacity">
            <summary>
            
            </summary>
        </member>
        <member name="P:socket4net.ServiceArg.Period">
            <summary>
            
            </summary>
        </member>
        <member name="T:socket4net.IService">
            <summary>
             STA service
            </summary>
        </member>
        <member name="M:socket4net.IService.Perform(System.Action)">
            <summary>
                Send action to be excuted in current service
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:socket4net.IService.Perform``1(System.Action{``0},``0)">
            <summary>
                Send action to be excuted in current service
            </summary>
            <param name="action"></param>
            <param name="param"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:socket4net.IService.Capacity">
            <summary>
                Jobs queued upper bound
            </summary>
        </member>
        <member name="P:socket4net.IService.Period">
            <summary>
                Period for waiting concurrent collection's item take
            </summary>
        </member>
        <member name="T:socket4net.INetService">
            <summary>
                net work service
            </summary>
        </member>
        <member name="T:socket4net.ILogicService">
            <summary>
                Logic service
                Timer schedule is running on Logic service
            </summary>
        </member>
        <member name="E:socket4net.ILogicService.Idle">
            <summary>
                Idle event
                Raised when no more jobs in a frame
            </summary>
        </member>
        <member name="P:socket4net.ILogicService.Scheduler">
            <summary>
                Timer scheduler
            </summary>
        </member>
        <member name="P:socket4net.ILogicService.CoroutineScheduler">
            <summary>
                Coroutine scheduler
            </summary>
        </member>
        <member name="P:socket4net.ILogicService.ElapsedMilliseconds">
            <summary>
                Elapsed ms since process started
            </summary>
        </member>
        <member name="T:socket4net.AutoLogicService">
            <summary>
                自动逻辑服务
                定时器刷新以及Jobs队列的刷新完全由本模块自理
            </summary>
        </member>
        <member name="T:socket4net.LogicServiceBase">
            <summary>
                逻辑服务
                1、可将多线程任务转换为单线程任务
                2、提供定时调度、协程调度服务
            </summary>
        </member>
        <member name="M:socket4net.LogicServiceBase.Perform(System.Action)">
            <summary>
            在本服务执行该Action
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:socket4net.LogicServiceBase.Perform``1(System.Action{``0},``0)">
            <summary>
            在本服务执行该Action
            </summary>
            <param name="action"></param>
            <param name="param"></param>
        </member>
        <member name="M:socket4net.LogicServiceBase.Enqueue(socket4net.IJob)">
            <summary>
                External(e.g. the TCP socket thread) call this method to push
                a work item into the working queue. The work item must not
                be null.
            </summary>
            <param name="w">the work item object, must not be null</param>
        </member>
        <member name="M:socket4net.LogicServiceBase.Enqueue``1(System.Action{``0},``0)">
            <summary>
                External(e.g. the TCP socket thread) call this method to push
                a work item into the working queue.
            </summary>
            <param name="proc">the working procedure</param>
            <param name="param">additional parameter that passed to working procedure</param>
        </member>
        <member name="M:socket4net.LogicServiceBase.Enqueue(System.Action)">
            <summary>
            入队
            </summary>
            <param name="proc"></param>
        </member>
        <member name="M:socket4net.LogicServiceBase.CalcPerformance">
            <summary>
            计算性能
            </summary>
        </member>
        <member name="P:socket4net.LogicServiceBase.Scheduler">
            <summary>
                定时器调度器
            </summary>
        </member>
        <member name="P:socket4net.LogicServiceBase.CoroutineScheduler">
            <summary>
                协程调度器
            </summary>
        </member>
        <member name="E:socket4net.LogicServiceBase.Idle">
            <summary>
                Idle event, call by working thread
                every period.
                <remarks>
                    generally the working thread
                    call the event every period, but if it's too busy
                    because the working item consumes too much time,
                    the calling period may grater than the original period
                </remarks>
            </summary>
        </member>
        <member name="P:socket4net.LogicServiceBase.QueueCapacity">
            <summary>
                Specify the capacity of the working item queue.
                <remarks>
                    when the items count in working queue reach the capacity
                    of the queue, all producer will block until there is one or more slot being free
                </remarks>
            </summary>
        </member>
        <member name="P:socket4net.LogicServiceBase.Period">
            <summary>
                Specify the working period of the working thread in milliseconds.
                That is, every period,the working thread loop back to the working
                procedure's top. and, the Idle event is called.
            </summary>
        </member>
        <member name="P:socket4net.LogicServiceBase.WiElapsed">
            <summary>
                A time counter that count the work items consume how much time
                in one working thread's loop. It maybe grater than the working period,
                which indicates the work items consume too much time.
            </summary>
        </member>
        <member name="P:socket4net.LogicServiceBase.IdleCallbackElapsed">
            <summary>
                A time counter that count the Idle event callbacks consume how much
                time in one working thread's loop. This value should be less than period.
            </summary>
        </member>
        <member name="P:socket4net.LogicServiceBase.Jobs">
            <summary>
                Specify the work items count currently in working queue.
            </summary>
        </member>
        <member name="P:socket4net.LogicServiceBase.ExcutedJobsPerSec">
            <summary>
            性能指标
            每秒执行的Job
            </summary>
        </member>
        <member name="P:socket4net.LogicServiceBase.Capacity">
            <summary>
            Job队列容量
            由上层指定
            </summary>
        </member>
        <member name="P:socket4net.LogicServiceBase.ElapsedMilliseconds">
            <summary>
                Get the elapsed milliseconds since the instance been constructed
            </summary>
        </member>
        <member name="M:socket4net.AutoLogicService.Enqueue(socket4net.IJob)">
            <summary>
            External(e.g. the TCP socket thread) call this method to push
            a work item into the working queue. The work item must not
            be null.
            </summary>
            <param name="w">the work item object, must not be null</param>
        </member>
        <member name="M:socket4net.AutoLogicService.DoStartup">
            <summary>
            do actually startup job
            </summary>
        </member>
        <member name="M:socket4net.AutoLogicService.WorkingProcedure">
            <summary>
            working thread's working procedure
            </summary>
        </member>
        <member name="P:socket4net.AutoLogicService.Jobs">
            <summary>
            Specify the work items count currently in working queue.
            </summary>
        </member>
        <member name="T:socket4net.PassiveLogicService">
            <summary>
                被动逻辑服务
                即：需要上层驱动本服务定时器、Job队列的更新
            </summary>
        </member>
        <member name="T:socket4net.NetService">
            <summary>
            网络服务线程（网络数据读写）
            </summary>
        </member>
        <member name="T:socket4net.Timer">
            <summary>
            A timer class base on Linux style timer scheduler.
            </summary>
        </member>
        <member name="M:socket4net.Timer.#ctor(System.String,System.UInt32,System.UInt32)">
            <summary>
            Construct a new timer object.
            </summary>
            <param name="service"></param>
            <param name="name">the timer's name</param>
            <param name="dueTime">when to begin this timer, in milliseconds.
            zero means start immediately</param>
            <param name="period">the period of this timer, , in milliseconds.
            zero means the timer is schedule once only</param>
        </member>
        <member name="M:socket4net.Timer.#ctor(System.String,System.UInt32)">
            <summary>
            Construct a new timer object.
            </summary>
            <param name="service"></param>
            <param name="name">the timer's name</param>
            <param name="dueTime">when to begin this timer, in milliseconds.
            zero means start immediately</param>
        </member>
        <member name="M:socket4net.Timer.Trigger">
            <summary>
            Call the timer's callback events.
            This method is called by <c>TimerScheduler</c> class only.
            </summary>
        </member>
        <member name="M:socket4net.Timer.Start">
            <summary>
            Start the timer.
            </summary>
        </member>
        <member name="M:socket4net.Timer.Stop">
            <summary>
            Stop the timer.
            </summary>
        </member>
        <member name="P:socket4net.Timer.Name">
            <summary>
            Time's name
            </summary>
        </member>
        <member name="P:socket4net.Timer.DueTime">
            <summary>
            When to start the timer, in milliseconds.
            </summary>
        </member>
        <member name="P:socket4net.Timer.Period">
            <summary>
            The timer period, in milliseconds.
            </summary>
        </member>
        <member name="P:socket4net.Timer.IsPeriod">
            <summary>
            Indicate it's a period timer or not.
            </summary>
        </member>
        <member name="P:socket4net.Timer.IsStarted">
            <summary>
            Indicate whether the timer is start or not.
            </summary>
        </member>
        <member name="P:socket4net.Timer.State">
            <summary>
            User define parameter.
            </summary>
        </member>
        <member name="P:socket4net.Timer.Expires">
            <summary>
            The expire time.
            this property only be used by <c>TimerScheduler</c> class.
            </summary>
        </member>
        <member name="P:socket4net.Timer.Entry">
            <summary>
            When timer is started, it's put in queue, this property is
            the queue entry for this timer object.
            this property only be used by <c>TimerScheduler</c> class.
            </summary>
        </member>
        <member name="E:socket4net.Timer.Arrived">
            <summary>
            When timer is trigger, this event will be called.
            </summary>
        </member>
        <member name="T:socket4net.QueueEntry">
            <summary>
            Queue entry class
            </summary>
        </member>
        <member name="M:socket4net.QueueEntry.#ctor(socket4net.Timer)">
            <summary>
            Construct a new entry object with a timer object.
            </summary>
            <param name="t">a non-null timer object</param>
        </member>
        <member name="M:socket4net.QueueEntry.#ctor">
            <summary>
            Construct a new head entry. That is, it's Prev/Next properties
            are point to itself.
            </summary>
        </member>
        <member name="M:socket4net.QueueEntry.QueueTail(socket4net.QueueEntry)">
            <summary>
            Queue the entry object into a queue specify by 'h'
            </summary>
            <param name="h">the entry object, must be a head entry object</param>
        </member>
        <member name="M:socket4net.QueueEntry.DeQueue">
            <summary>
            Dequeue the entry object
            </summary>
        </member>
        <member name="M:socket4net.QueueEntry.Discard">
            <summary>
            UnBinding the timer object
            </summary>
        </member>
        <member name="P:socket4net.QueueEntry.Prev">
            <summary>
            The Preview entry object
            </summary>
        </member>
        <member name="P:socket4net.QueueEntry.Next">
            <summary>
            The next entry object
            </summary>
        </member>
        <member name="P:socket4net.QueueEntry.Timer">
            <summary>
            The timer object
            </summary>
        </member>
        <member name="T:socket4net.TimerConstant">
            <summary>
            Define the constant variable used by <c>TimerScheduler</c> class
            </summary>
        </member>
        <member name="T:socket4net.TVN">
            <summary>
            Timer vector class.
            </summary>
        </member>
        <member name="T:socket4net.TVR">
            <summary>
            Timer vector class.
            It's a specific type of <c>TVN</c>, it's vector size
            is different from <c>TVN</c>.
            </summary>
        </member>
        <member name="T:socket4net.TimerScheduler">
            <summary>
            A Linux style timer scheduler
            </summary>
        </member>
        <member name="F:socket4net.TimerScheduler._timerJiffies">
            <summary>
            This field used to store how many milliseconds
            elapsed since this scheduler been constructed.
            All timer's expire time is calculated base on this field.
            </summary>
        </member>
        <member name="F:socket4net.TimerScheduler._runningTimer">
            <summary>
            When scheduler is trigger a timer, this field store the timer object.
            </summary>
        </member>
        <member name="F:socket4net.TimerScheduler._TV1">
            <summary>
            The first class of timers vector, their expire time will less than 256 milliseconds.
            </summary>
        </member>
        <member name="F:socket4net.TimerScheduler._TV2">
            <summary>
            The second class of timers vector, their expire time will grater than 255 milliseconds
            and less than 16384(1 left shit 14) milliseconds
            </summary>
        </member>
        <member name="F:socket4net.TimerScheduler._TV3">
            <summary>
            The second class of timers vector, their expire time will grater than 16384 milliseconds
            and less than 1048576(1 left shit 20) milliseconds
            </summary>
        </member>
        <member name="F:socket4net.TimerScheduler._TV4">
            <summary>
            The second class of timers vector, their expire time will grater than 1048576 milliseconds
            and less than 67108864(1 left shit 26) milliseconds
            </summary>
        </member>
        <member name="F:socket4net.TimerScheduler._TV5">
            <summary>
            The second class of timers vector, their expire time will grater than 67108864 milliseconds
            and less than uint.Max(1 left shit 32) milliseconds
            if the expires is grater then uint.Max, it will be truncated.
            </summary>
        </member>
        <member name="M:socket4net.TimerScheduler.RunTimer">
            <summary>
            <c>StaService</c>'s Idle event call this method
            to check all expired timers.
            </summary>
        </member>
        <member name="M:socket4net.TimerScheduler.Add(socket4net.Timer)">
            <summary>
            Put a timer object in scheduler's queue.
            </summary>
            <param name="t">the timer object</param>
        </member>
        <member name="M:socket4net.TimerScheduler.Remove(socket4net.Timer)">
            <summary>
            remove a timer object from scheduler's queue.
            </summary>
            <param name="t">the timer object</param>
        </member>
        <member name="M:socket4net.TimerScheduler.Cascade(socket4net.TVN,System.Int32)">
            <summary>
            Cascade a timers vector
            </summary>
            <param name="tv">the timers vector</param>
            <param name="index">which queue to cascade</param>
            <returns></returns>
        </member>
        <member name="M:socket4net.TimerScheduler.Cascade">
            <summary>
            Cascade all timers vectors
            </summary>
        </member>
        <member name="M:socket4net.TimerScheduler.InternalAdd(socket4net.QueueEntry)">
            <summary>
            Queue an entry object into a suitable timer queue.
            </summary>
            <param name="e">the entry object</param>
        </member>
    </members>
</doc>
